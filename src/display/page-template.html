<html>
  <style> /* set the CSS */
    div.tooltip {
        position: absolute;
        text-align: center;
        width: 80px;
        height: 80px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }
  </style>
  <head></head>
  <body>
      <script src="https://d3js.org/d3.v7.min.js"></script>
      <script>
        // The raw data
        const contributorNodes = $$CONTRIBUTOR_NODES$$;
        const challengeNodes = $$CHALLENGE_NODES$$;
        const eges = $$EDGES$$;

        /////////////////////////////////////////////////////////////////////////////////////////

        var margin = {top: 30, right: 20, bottom: 30, left: 50};
        const width = 2000 - margin.left - margin.right;
        const height = 1600 - margin.top - margin.bottom;

        const vertGroupsMap = new Map();

        let yMax = 0;
        for (const utxoNode of challengeNodes) {
          let yVal = 0;
          const group = vertGroupsMap.get(utxoNode.wallet);
          if (!group) {
            yMax = yMax + 100;
            yVal = yMax;
            // anchor jaaps at the bottom
            if (utxoNode.who === 'Jaap') {
              yVal = height - 50;
            }
            vertGroupsMap.set(utxoNode.wallet, yVal);
          }
        }

        const vertGroupsKeys = vertGroupsMap.keys();
        for (const vertGroup of vertGroupsKeys) {
          console.log(`${vertGroup} - ${vertGroupsMap.get(vertGroup)}`)
        }


        var valueline = d3.line()
          .x(function(d) { return d[0]; })
          .y(function(d) { return d[1]; })
          .curve(d3.curveCatmullRomClosed);

        var curveType = "curveBasisClosed";
        const d3Category10 = d3.schemeCategory10
        var color = d3.scaleOrdinal(d3Category10);

        // Page setup
        var div = d3.select("body").append("div")
            .attr("class", "tooltip").style("opacity", 0);
        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var svfDefs = svg.append('defs');
        var arrowHeadDef = svfDefs.append('marker')
              .attr('id', 'arrowhead')
              .attr('viewBox', '-0 -5 10 10')
              .attr('refX', 13)
              .attr('refY', 0)
              .attr('orient', 'auto')
              .attr('markerWidth', 5)
              .attr('markerHeight', 5)
              .attr('xoverflow', 'visible')
              .append('svg:path')
              .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
              .attr('fill', '#999')
              .style('stroke','none');


        // Scale the block height to be on the x-axis
        const xScale = d3.scaleLinear().domain([0, contributorNodes.length]).range([50, width - 50]);
        const yScale = d3.scaleLinear().domain([0, yMax]).range([50, height - 50]);
        const txSizeScale = d3.scaleSqrt().domain([0, 50]).range([8, 60]);

        const nodes = contributorNodes.concat(challengeNodes);
        const graphData = {
          nodes: nodes,
          links: eges
        }

        const graphLayout = d3.forceSimulation(graphData.nodes)
          .force("link", d3.forceLink(graphData).id((d, i) => d.id).distance(30).strength(0.3))
          .force('charge', d3.forceManyBody().strength(-50))
          .force('x', d3.forceX().x(function(d) {
            if (d.group === 'tx') {
              return xScale(d.anchor);
            } else {
              return xScale(d.anchor + 5);
            }
          }))
          .force('y', d3.forceY().y(function(d) {
            if (d.group === 'tx') {
              var yAnchor = parseInt(vertGroupsMap.get(d.wallet));
              return yScale(yAnchor);
            }
            else {
              var yAnchor = parseInt(vertGroupsMap.get(d.group));
              return yScale(yAnchor);
            }
          }))
          .force('collision', d3.forceCollide().radius(function(d) {
            return d.radius;
          }).strength(-100));


        const node = svg.append("g").attr("class", "nodes")
            .attr("stroke", "#fff")
            .attr("stroke-width", 1.5)
            .selectAll("circle")
            .data(graphData.nodes)
            .join("circle")
            .attr("r", function(d, i) {
                if (d.group === "tx") return 5;
                // utxo group
                return txSizeScale(d.amount);
              } )
            .attr("fill", function(d, i) {
                if (d.group === "tx") return "black";
                return color(d.group);
              } )
            .attr('stroke', function(d, i) {
                if (d.group === "tx") return "black";
                // is a utxo
                return color(`${d.who}-xxx`);
              } )
            .attr('stroke-width', 4)
            .attr("fx", function(d, i) {
              if (d.group === "tx") return xScale(i);
            } )
            .on("mouseover", mouseOverNode)
            .on("mouseout", function(d) {
                div.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .call(drag(graphLayout));

        const link = svg.append("g").attr("class", "links")
            .attr("stroke", "#999")
            .attr("stroke-opacity", 0.6)
            .selectAll("line")
            .data(graphData.links)
            .join("line")
            .attr("stroke-width", 1)
            .attr('marker-end','url(#arrowhead)');


        graphLayout
          .nodes(graphData.nodes)
          .on('tick', ticked)
          .force('link')
          .links(graphData.links);

        // todo: losing the axis labels when zooming
        svg.append('g').call(d3.axisBottom(xScale));

        function ticked() {
          link
              .attr("x1", function(d, i) {
                  if (d.source.group === "tx") {
                    return xScale(d.source.index);
                  }
                  return d.source.x
                } )
              .attr("y1", function(d, i) {
                  if (d.source.group === "tx") {
                    return d.source.y;
                  }
                  var yAnchor = parseInt(vertGroupsMap.get(d.source.group));
                  return yScale(yAnchor);
                })
              .attr("x2", function(d, i) {
                  if (d.target.group === "tx") {
                    return xScale(d.target.index);
                  }
                  return d.target.x
                } )
              .attr("y2", function(d, i) {
                  if (d.target.group === "tx") {
                    return d.target.y;
                  }
                  var yAnchor = parseInt(vertGroupsMap.get(d.target.group));
                  return yScale(yAnchor);
                })
          node
              .attr("cx", function(d, i) {
                if (d.group === "tx") {
                  return xScale(i);
                }
                return d.x
              } )
              .attr("cy", function(d, i) {
                if (d.group === "tx") {
                  return d.y
                }
                var yAnchor = parseInt(vertGroupsMap.get(d.group));
                return yScale(yAnchor);
              } )
        }

        function mouseOverNode(d) {
          const nodeData = this.__data__;
          const leftPosition = (d.pageX) + "px";
          const topPosition = (d.pageY -28) + "px";
          div.transition()
              .duration(200)
              .style("opacity", .9);
          var labelText = '';
          if (nodeData.group === "tx") {
            labelText = `TX:&nbsp;<b>${nodeData.id.substring(0,10)}...</b><br/>Blockheight:&nbsp;${nodeData.blockheight}`;
          } else {
            labelText = `UTXO:&nbsp;<b>${nodeData.id.substring(0,10)}...</b><br/>Amount:&nbsp;${nodeData.amount}<br/>Wallet:&nbsp;${nodeData.wallet}<br/>Spent:&nbsp;${nodeData.isSpent}<br/>Who:&nbsp;${nodeData.who}<br/>Device:&nbsp;${nodeData.device}`;
          }
          div.html(labelText)
              .style("left", leftPosition)
              .style("top", topPosition);
        }

        function click() {
          if (d3.select(this).attr("class") == "nodes") {
            // do something
          }
        }

        function drag(graphLayout) {
          function dragstarted(event) {
            if (!event.active) graphLayout.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
          }

          function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
          }

          function dragended(event) {
            if (!event.active) graphLayout.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
          }

          return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
        }

        // allow zooming
        function handleZoom(e) {
          d3.select('svg').selectAll('g')
            .attr('transform', e.transform);
        }
        let zoom = d3.zoom()
          .on('zoom', handleZoom);

        d3.select('svg')
          .call(zoom);

      </script>
    </div>
  </body>
</html>